<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Haskell code</title>
</head>
<body>
<pre><a name="line-1"></a><font color=Blue><i>{-# LANGUAGE Unsafe #-}</i></font>
<a name="line-2"></a><font color=Blue><i>{-# LANGUAGE TypeSynonymInstances #-}</i></font>
<a name="line-3"></a><font color=Blue><i>{-# LANGUAGE FlexibleInstances #-}</i></font>
<a name="line-4"></a>
<a name="line-5"></a><font color=Blue><i>{-# LANGUAGE CPP #-}</i></font>
<a name="line-6"></a><font color=Magenta><em>#if __GLASGOW_HASKELL__ &lt; 710</em></font>
<a name="line-7"></a>  <font color=Blue><i>{-# LANGUAGE OverlappingInstances #-}</i></font>
<a name="line-8"></a><font color=Magenta><em>#endif</em></font>
<a name="line-9"></a>
<a name="line-10"></a><font color=Blue><i>-- | This module contains an efficient representation of algebraic</i></font>
<a name="line-11"></a><font color=Blue><i>-- boolean formulas.</i></font>
<a name="line-12"></a><font color=Green><u>module</u></font> Quipper.Libraries.ClassicalOptim.AlgExp <font color=Green><u>where</u></font>
<a name="line-13"></a>
<a name="line-14"></a><font color=Green><u>import</u></font> <font color=Green><u>qualified</u></font> Data.Map <font color=Green><u>as</u></font> M
<a name="line-15"></a><font color=Green><u>import</u></font> <font color=Green><u>qualified</u></font> Data.List <font color=Green><u>as</u></font> L
<a name="line-16"></a><font color=Green><u>import</u></font> <font color=Green><u>qualified</u></font> Data.Set <font color=Green><u>as</u></font> S
<a name="line-17"></a><font color=Green><u>import</u></font> <font color=Green><u>qualified</u></font> Data.IntSet <font color=Green><u>as</u></font> IS
<a name="line-18"></a><font color=Green><u>import</u></font> <font color=Green><u>qualified</u></font> Data.IntMap.Strict <font color=Green><u>as</u></font> IM <font color=Blue><i>{- containers-0.5.2.1 -}</i></font>
<a name="line-19"></a>
<a name="line-20"></a><font color=Green><u>import</u></font> Quipper.Utils.Auxiliary <font color=Cyan>(</font>bool_xor<font color=Cyan>)</font>
<a name="line-21"></a>
<a name="line-22"></a><font color=Green><u>import</u></font> Quipper.Libraries.ClassicalOptim.Circuit
<a name="line-23"></a>
<a name="line-24"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-25"></a><font color=Blue><i>-- * Auxiliary functions</i></font>
<a name="line-26"></a>
<a name="line-27"></a><a name="mapOfSet"></a><font color=Blue><i>-- | Build the characteristic function of a set.</i></font>
<a name="line-28"></a><font color=Blue>mapOfSet</font> <font color=Red>::</font> Ord a <font color=Red>=&gt;</font> S.Set a <font color=Red>-&gt;</font> M.Map a Int
<a name="line-29"></a><font color=Blue>mapOfSet</font> s <font color=Red>=</font> S.foldl' <font color=Cyan>(</font><font color=Red>\</font>m x <font color=Red>-&gt;</font> M.insert x <font color=Magenta>1</font> m<font color=Cyan>)</font> M.empty s
<a name="line-30"></a>
<a name="line-31"></a><a name="setOfMap"></a><font color=Blue><i>-- | Get the set of elements whose images are odd.</i></font>
<a name="line-32"></a><font color=Blue>setOfMap</font> <font color=Red>::</font> Ord a <font color=Red>=&gt;</font> M.Map a Int <font color=Red>-&gt;</font> S.Set a
<a name="line-33"></a><font color=Blue>setOfMap</font> m <font color=Red>=</font> 
<a name="line-34"></a>    M.foldlWithKey' <font color=Cyan>(</font><font color=Red>\</font>s x <font color=Green><u>_</u></font> <font color=Red>-&gt;</font> S.insert x s<font color=Cyan>)</font> S.empty <font color=Cyan>$</font> 
<a name="line-35"></a>          M.filter <font color=Cyan>(</font><font color=Red>\</font>x <font color=Red>-&gt;</font> mod x <font color=Magenta>2</font> <font color=Cyan>==</font> <font color=Magenta>1</font><font color=Cyan>)</font> m
<a name="line-36"></a>
<a name="line-37"></a><a name="split_even"></a><font color=Blue><i>-- | Split a list in the middle.</i></font>
<a name="line-38"></a><font color=Blue>split_even</font> <font color=Red>::</font> <font color=Red>[</font>a<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font><font color=Red>[</font>a<font color=Red>]</font><font color=Cyan>,</font><font color=Red>[</font>a<font color=Red>]</font><font color=Cyan>)</font>
<a name="line-39"></a><font color=Blue>split_even</font> a <font color=Red>=</font> splitAt <font color=Cyan>(</font>div <font color=Cyan>(</font>length a<font color=Cyan>)</font> <font color=Magenta>2</font><font color=Cyan>)</font> a
<a name="line-40"></a>
<a name="line-41"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-42"></a><font color=Blue><i>-- * Expressions</i></font>
<a name="line-43"></a>
<a name="line-44"></a><a name="Exp"></a><font color=Blue><i>-- | The type of algebraic boolean expressions. </i></font>
<a name="line-45"></a><a name="Exp"></a><font color=Blue><i>-- </i></font>
<a name="line-46"></a><a name="Exp"></a><font color=Blue><i>-- We represent boolean expressions using \"and\" and \"xor\" as the</i></font>
<a name="line-47"></a><a name="Exp"></a><font color=Blue><i>-- primitive connectives. Equivalently, we can regard booleans as the</i></font>
<a name="line-48"></a><a name="Exp"></a><font color=Blue><i>-- elements of the two-element field /F/[sub 2], with operations \"*\"</i></font>
<a name="line-49"></a><a name="Exp"></a><font color=Blue><i>-- (times) and \"+\" (plus). </i></font>
<a name="line-50"></a><a name="Exp"></a><font color=Blue><i>-- </i></font>
<a name="line-51"></a><a name="Exp"></a><font color=Blue><i>-- An algebraic expression</i></font>
<a name="line-52"></a><a name="Exp"></a><font color=Blue><i>--      @x1*x2*x3 + y1*y2*y3 + z1*z2@</i></font>
<a name="line-53"></a><a name="Exp"></a><font color=Blue><i>-- is encoded as</i></font>
<a name="line-54"></a><a name="Exp"></a><font color=Blue><i>--      @{{x1,x2,x3},{y1,y2,y3},{z1,z2}}@.</i></font>
<a name="line-55"></a><a name="Exp"></a><font color=Blue><i>-- </i></font>
<a name="line-56"></a><a name="Exp"></a><font color=Blue><i>-- In particular,</i></font>
<a name="line-57"></a><a name="Exp"></a><font color=Blue><i>--     @{}   == False == 0@ and </i></font>
<a name="line-58"></a><a name="Exp"></a><font color=Blue><i>--     @{{}} == True  == 1@.</i></font>
<a name="line-59"></a><a name="Exp"></a><font color=Green><u>type</u></font> Exp <font color=Red>=</font> S.Set IS.IntSet
<a name="line-60"></a>
<a name="line-61"></a><a name="instance"></a><font color=Green><u>instance</u></font> <font color=Blue><i>{-# OVERLAPPING #-}</i></font> Show Exp <font color=Green><u>where</u></font>
<a name="line-62"></a>    show e <font color=Red>=</font> <font color=Green><u>if</u></font> <font color=Cyan>(</font>S.null e<font color=Cyan>)</font> <font color=Green><u>then</u></font> <font color=Magenta>"F"</font>
<a name="line-63"></a>             <font color=Green><u>else</u></font> <font color=Green><u>if</u></font> <font color=Cyan>(</font>e <font color=Cyan>==</font> S.singleton <font color=Cyan>(</font>IS.empty<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Green><u>then</u></font> <font color=Magenta>"T"</font>
<a name="line-64"></a>             <font color=Green><u>else</u></font> L.concat <font color=Cyan>$</font> L.intersperse <font color=Magenta>"+"</font> <font color=Cyan>(</font>L.map <font color=Cyan>(</font><font color=Red>\</font>e <font color=Red>-&gt;</font> L.concat <font color=Cyan>$</font> L.map <font color=Cyan>(</font><font color=Red>\</font>x <font color=Red>-&gt;</font> <font color=Magenta>"x"</font> <font color=Cyan>++</font> <font color=Cyan>(</font>show x<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Cyan>$</font> IS.toList e<font color=Cyan>)</font> <font color=Cyan>$</font> S.toList e<font color=Cyan>)</font>
<a name="line-65"></a>
<a name="line-66"></a><a name="listOfExp"></a><font color=Blue><i>-- | Turn an @Exp@ into a list of lists.</i></font>
<a name="line-67"></a><font color=Blue>listOfExp</font> <font color=Red>::</font> Exp <font color=Red>-&gt;</font> <font color=Red>[</font><font color=Red>[</font>Int<font color=Red>]</font><font color=Red>]</font>
<a name="line-68"></a><font color=Blue>listOfExp</font> e <font color=Red>=</font> S.toList <font color=Cyan>$</font> S.map IS.toList e
<a name="line-69"></a>
<a name="line-70"></a><a name="expOfList"></a><font color=Blue><i>-- | Turn a list of lists into an @Exp@.</i></font>
<a name="line-71"></a><font color=Blue>expOfList</font> <font color=Red>::</font> <font color=Red>[</font><font color=Red>[</font>Int<font color=Red>]</font><font color=Red>]</font> <font color=Red>-&gt;</font> Exp
<a name="line-72"></a><font color=Blue>expOfList</font> l <font color=Red>=</font> S.fromList <font color=Cyan>$</font> L.map IS.fromList l
<a name="line-73"></a>
<a name="line-74"></a><a name="exp_and"></a><font color=Blue><i>-- | The conjunction of two expression.</i></font>
<a name="line-75"></a><font color=Blue>exp_and</font> <font color=Red>::</font> Exp <font color=Red>-&gt;</font> Exp <font color=Red>-&gt;</font> Exp
<a name="line-76"></a><font color=Blue>exp_and</font> a b <font color=Red>=</font> 
<a name="line-77"></a>    setOfMap <font color=Cyan>$</font>
<a name="line-78"></a>    S.foldl <font color=Cyan>(</font><font color=Red>\</font>exp monomial <font color=Red>-&gt;</font> M.unionWith <font color=Cyan>(</font><font color=Cyan>+</font><font color=Cyan>)</font> exp <font color=Cyan>$</font> exp_and_aux monomial <font color=Cyan>$</font> mapOfSet a<font color=Cyan>)</font> M.empty b
<a name="line-79"></a>  <font color=Green><u>where</u></font>
<a name="line-80"></a>    exp_and_aux <font color=Red>::</font> IS.IntSet <font color=Red>-&gt;</font> M.Map IS.IntSet Int <font color=Red>-&gt;</font> M.Map IS.IntSet Int
<a name="line-81"></a>    exp_and_aux monomial exp <font color=Red>=</font>  M.mapKeysWith <font color=Cyan>(</font><font color=Cyan>+</font><font color=Cyan>)</font> <font color=Cyan>(</font>IS.union monomial<font color=Cyan>)</font> exp
<a name="line-82"></a>
<a name="line-83"></a><a name="exp_xor"></a><font color=Blue><i>-- | The xor of two expressions.</i></font>
<a name="line-84"></a><font color=Blue>exp_xor</font> <font color=Red>::</font> Exp <font color=Red>-&gt;</font> Exp <font color=Red>-&gt;</font> Exp
<a name="line-85"></a><font color=Blue>exp_xor</font> a b <font color=Red>=</font> setOfMap <font color=Cyan>$</font> M.unionWith <font color=Cyan>(</font><font color=Cyan>+</font><font color=Cyan>)</font> <font color=Cyan>(</font>mapOfSet a<font color=Cyan>)</font> <font color=Cyan>(</font>mapOfSet b<font color=Cyan>)</font>
<a name="line-86"></a>
<a name="line-87"></a><a name="exp_false"></a><font color=Blue><i>-- | The expression \"False\".</i></font>
<a name="line-88"></a><font color=Blue>exp_false</font> <font color=Red>::</font> Exp
<a name="line-89"></a><font color=Blue>exp_false</font> <font color=Red>=</font> S.empty
<a name="line-90"></a>
<a name="line-91"></a><a name="exp_true"></a><font color=Blue><i>-- | The expression \"True\".</i></font>
<a name="line-92"></a><font color=Blue>exp_true</font> <font color=Red>::</font> Exp
<a name="line-93"></a><font color=Blue>exp_true</font> <font color=Red>=</font> S.singleton IS.empty
<a name="line-94"></a>
<a name="line-95"></a><a name="exp_not"></a><font color=Blue><i>-- | The negation of an expression.</i></font>
<a name="line-96"></a><font color=Blue>exp_not</font> <font color=Red>::</font> Exp <font color=Red>-&gt;</font> Exp 
<a name="line-97"></a><font color=Blue>exp_not</font> e <font color=Red>=</font> exp_xor e exp_true
<a name="line-98"></a>
<a name="line-99"></a><a name="exp_var"></a><font color=Blue><i>-- | The expression /x/[sub /n/].</i></font>
<a name="line-100"></a><font color=Blue>exp_var</font> <font color=Red>::</font> Int <font color=Red>-&gt;</font> Exp
<a name="line-101"></a><font color=Blue>exp_var</font> x <font color=Red>=</font> S.singleton <font color=Cyan>$</font> IS.singleton x
<a name="line-102"></a>
<a name="line-103"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-104"></a><font color=Blue><i>-- * Properties of expressions</i></font>
<a name="line-105"></a>
<a name="line-106"></a><font color=Blue><i>-- $ The important property of expressions is that two formulas have</i></font>
<a name="line-107"></a><font color=Blue><i>-- the same truth table iff they are syntactically equal. This makes</i></font>
<a name="line-108"></a><font color=Blue><i>-- the equality test of wires theoretically straightforward.</i></font>
<a name="line-109"></a>
<a name="line-110"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-111"></a><font color=Blue><i>-- ** Truth tables</i></font>
<a name="line-112"></a>
<a name="line-113"></a><font color=Blue><i>-- $ A /valuation/ on a set of variables is a map from variables to</i></font>
<a name="line-114"></a><font color=Blue><i>-- booleans. This can be thought of as a row in a truth table. A</i></font>
<a name="line-115"></a><font color=Blue><i>-- /truth table/ is a map from valuations to booleans, but we just</i></font>
<a name="line-116"></a><font color=Blue><i>-- represent this as a list of booleans, listed in lexicographically</i></font>
<a name="line-117"></a><font color=Blue><i>-- increasing order of valuations.</i></font>
<a name="line-118"></a>
<a name="line-119"></a><a name="vars_of_exp"></a><font color=Blue><i>-- | Get the variables used in an expression.</i></font>
<a name="line-120"></a><font color=Blue>vars_of_exp</font> <font color=Red>::</font> Exp <font color=Red>-&gt;</font> <font color=Red>[</font>Int<font color=Red>]</font>
<a name="line-121"></a><font color=Blue>vars_of_exp</font> e <font color=Red>=</font> IS.toList <font color=Cyan>$</font> S.foldl <font color=Cyan>(</font><font color=Red>\</font>a b <font color=Red>-&gt;</font> IS.union a b<font color=Cyan>)</font> IS.empty e
<a name="line-122"></a>
<a name="line-123"></a><a name="exp_eval"></a><font color=Blue><i>-- | Evaluate the expression with respect to the given valuation. A</i></font>
<a name="line-124"></a><font color=Blue><i>-- /valuation/ is a map from variables to booleans, i.e., a row in a</i></font>
<a name="line-125"></a><font color=Blue><i>-- truth table.</i></font>
<a name="line-126"></a><font color=Blue>exp_eval</font> <font color=Red>::</font> Exp <font color=Red>-&gt;</font> M.Map Int Bool <font color=Red>-&gt;</font> Bool
<a name="line-127"></a><font color=Blue>exp_eval</font> e m <font color=Red>=</font> L.foldl bool_xor False <font color=Cyan>$</font> L.map <font color=Cyan>(</font>L.foldl <font color=Cyan>(</font><font color=Cyan>&amp;&amp;</font><font color=Cyan>)</font> True<font color=Cyan>)</font> <font color=Cyan>$</font> L.map <font color=Cyan>(</font>L.map <font color=Cyan>(</font>m M<font color=Cyan>.!</font><font color=Cyan>)</font><font color=Cyan>)</font> <font color=Cyan>$</font> L.map <font color=Cyan>(</font>IS.toList<font color=Cyan>)</font> <font color=Cyan>$</font> S.toList e
<a name="line-128"></a>
<a name="line-129"></a><a name="valuations_of_vars"></a><font color=Blue><i>-- | Construct the list of all 2[super /n/] valuations for a given</i></font>
<a name="line-130"></a><font color=Blue><i>-- list of /n/ variables.</i></font>
<a name="line-131"></a><font color=Blue>valuations_of_vars</font> <font color=Red>::</font> <font color=Red>[</font>Int<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font>M.Map Int Bool<font color=Red>]</font>
<a name="line-132"></a><font color=Blue>valuations_of_vars</font> [] <font color=Red>=</font> <font color=Red>[</font>M.empty<font color=Red>]</font>
<a name="line-133"></a><font color=Blue>valuations_of_vars</font> <font color=Cyan>(</font>h<font color=Red><b>:</b></font>t<font color=Cyan>)</font> <font color=Red>=</font> l
<a name="line-134"></a>  <font color=Green><u>where</u></font>
<a name="line-135"></a>    l <font color=Red>=</font> <font color=Cyan>(</font>L.map <font color=Cyan>(</font>M.insert h False<font color=Cyan>)</font> v<font color=Cyan>)</font> <font color=Cyan>++</font> <font color=Cyan>(</font>L.map <font color=Cyan>(</font>M.insert h True<font color=Cyan>)</font> v<font color=Cyan>)</font>
<a name="line-136"></a>    v <font color=Red>=</font> valuations_of_vars t 
<a name="line-137"></a>
<a name="line-138"></a><a name="truth_table_of_exp"></a><font color=Blue><i>-- | Build the truth table for the given expression, on the given list</i></font>
<a name="line-139"></a><font color=Blue><i>-- of variables. The truth table is returned as a list of booleans in</i></font>
<a name="line-140"></a><font color=Blue><i>-- lexicographic order of valuations. For example, if</i></font>
<a name="line-141"></a><font color=Blue><i>-- </i></font>
<a name="line-142"></a><font color=Blue><i>-- &gt;  1 2 | exp</i></font>
<a name="line-143"></a><font color=Blue><i>-- &gt;  F F | f1</i></font>
<a name="line-144"></a><font color=Blue><i>-- &gt;  F T | f2</i></font>
<a name="line-145"></a><font color=Blue><i>-- &gt;  T F | f3</i></font>
<a name="line-146"></a><font color=Blue><i>-- &gt;  T T | f4</i></font>
<a name="line-147"></a><font color=Blue><i>-- </i></font>
<a name="line-148"></a><font color=Blue><i>-- then the output of the function is @[f1,f2,f3,f4]@.</i></font>
<a name="line-149"></a><font color=Blue>truth_table_of_exp</font> <font color=Red>::</font> <font color=Red>[</font>Int<font color=Red>]</font> <font color=Red>-&gt;</font> Exp <font color=Red>-&gt;</font> <font color=Red>[</font>Bool<font color=Red>]</font>
<a name="line-150"></a><font color=Blue>truth_table_of_exp</font> vars e <font color=Red>=</font> L.map <font color=Cyan>(</font>exp_eval e<font color=Cyan>)</font> <font color=Cyan>(</font>valuations_of_vars vars<font color=Cyan>)</font>
<a name="line-151"></a>
<a name="line-152"></a><a name="exp_of_truth_table"></a><font color=Blue><i>-- | Return an expression realizing the given truth table. Uses</i></font>
<a name="line-153"></a><font color=Blue><i>-- variables starting with the given number.</i></font>
<a name="line-154"></a><font color=Blue>exp_of_truth_table</font> <font color=Red>::</font> Int <font color=Red>-&gt;</font> <font color=Red>[</font>Bool<font color=Red>]</font> <font color=Red>-&gt;</font> Exp
<a name="line-155"></a><font color=Blue>exp_of_truth_table</font> i [] <font color=Red>=</font> exp_true
<a name="line-156"></a><font color=Blue>exp_of_truth_table</font> i <font color=Red>[</font>False<font color=Red>]</font> <font color=Red>=</font> exp_false
<a name="line-157"></a><font color=Blue>exp_of_truth_table</font> i <font color=Red>[</font>True<font color=Red>]</font> <font color=Red>=</font> exp_true
<a name="line-158"></a><font color=Blue>exp_of_truth_table</font> i t <font color=Red>=</font> <font color=Cyan>(</font><font color=Cyan>(</font>exp_not <font color=Cyan>(</font>exp_var i<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Cyan>`exp_and`</font> e1<font color=Cyan>)</font> <font color=Cyan>`exp_xor`</font> <font color=Cyan>(</font><font color=Cyan>(</font>exp_var i<font color=Cyan>)</font> <font color=Cyan>`exp_and`</font> e2<font color=Cyan>)</font>
<a name="line-159"></a>  <font color=Green><u>where</u></font>
<a name="line-160"></a>    <font color=Cyan>(</font>t1<font color=Cyan>,</font>t2<font color=Cyan>)</font> <font color=Red>=</font> split_even t
<a name="line-161"></a>    e1 <font color=Red>=</font> exp_of_truth_table <font color=Cyan>(</font>i<font color=Cyan>+</font><font color=Magenta>1</font><font color=Cyan>)</font> t1
<a name="line-162"></a>    e2 <font color=Red>=</font> exp_of_truth_table <font color=Cyan>(</font>i<font color=Cyan>+</font><font color=Magenta>1</font><font color=Cyan>)</font> t2
<a name="line-163"></a>
</pre>
</body>
</html>