<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Quipper.Libraries.ClassicalOptim.QuipperInterface</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Quipper/Libraries/ClassicalOptim/QuipperInterface.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Quipper.Libraries.ClassicalOptim.QuipperInterface</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Auxiliary functions</a></li><li><a href="#g:2">Quipper circuits to simple circuits</a></li><li><a href="#g:3">Simple circuits to Quipper circuits</a></li><li><a href="#g:4">Algebraic optimization of Quipper circuits</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module contains the interface between the simplified circuit
 model and Quipper's internal circuit model. The main useful
 exported functions are: </p><ul><li><code><code><a href="Quipper-Libraries-ClassicalOptim-QuipperInterface.html#v:simplify_classical" title="Quipper.Libraries.ClassicalOptim.QuipperInterface">simplify_classical</a></code></code>, which optimizes a classical circuit such
 as those coming from Template Haskell;</li><li><code><code><a href="Quipper-Libraries-ClassicalOptim-QuipperInterface.html#v:classical_to_reversible_optim" title="Quipper.Libraries.ClassicalOptim.QuipperInterface">classical_to_reversible_optim</a></code></code>, which provides a mechanism
 equivalent to <code><code><a href="Quipper-Internal-Classical.html#v:classical_to_reversible" title="Quipper.Internal.Classical">classical_to_reversible</a></code></code>, but with optimization
 inlined.</li></ul></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:getListWire">getListWire</a> :: <a href="Quipper-Internal-QData.html#t:QData" title="Quipper.Internal.QData">QData</a> qc =&gt; qc -&gt; &#91;<a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a>&#93;</li><li class="src short"><a href="#v:quipperGateToMyGate">quipperGateToMyGate</a> :: (<a href="http://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-IntSet.html#t:IntSet" title="Data.IntSet">IntSet</a>, <a href="http://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-IntMap-Strict-Internal.html#t:IntMap" title="Data.IntMap.Strict.Internal">IntMap</a> <a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a>, <a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a>) -&gt; <a href="Quipper-Internal-Circuit.html#t:Gate" title="Quipper.Internal.Circuit">Gate</a> -&gt; ((<a href="http://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-IntSet.html#t:IntSet" title="Data.IntSet">IntSet</a>, <a href="http://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-IntMap-Strict-Internal.html#t:IntMap" title="Data.IntMap.Strict.Internal">IntMap</a> <a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a>, <a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a>), <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> <a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Gate" title="Quipper.Libraries.ClassicalOptim.Circuit">Gate</a>)</li><li class="src short"><a href="#v:quipperGateInitW">quipperGateInitW</a> :: <a href="Quipper-Internal-Circuit.html#t:Gate" title="Quipper.Internal.Circuit">Gate</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> <a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a></li><li class="src short"><a href="#v:quipperGateFreshWire">quipperGateFreshWire</a> :: <a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a> -&gt; &#91;<a href="Quipper-Internal-Circuit.html#t:Gate" title="Quipper.Internal.Circuit">Gate</a>&#93; -&gt; <a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a></li><li class="src short"><a href="#v:quipperCircuitToMyCirc">quipperCircuitToMyCirc</a> :: <a href="Quipper-Internal-Circuit.html#t:Circuit" title="Quipper.Internal.Circuit">Circuit</a> -&gt; <a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:CircState" title="Quipper.Libraries.ClassicalOptim.Circuit">CircState</a></li><li class="src short"><a href="#v:quipperBCircuitToMyCirc">quipperBCircuitToMyCirc</a> :: <a href="Quipper-Internal-Circuit.html#t:BCircuit" title="Quipper.Internal.Circuit">BCircuit</a> -&gt; <a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:CircState" title="Quipper.Libraries.ClassicalOptim.Circuit">CircState</a></li><li class="src short"><a href="#v:myCircErrMsg">myCircErrMsg</a> :: <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><a href="#v:quipperFunToMyCirc">quipperFunToMyCirc</a> :: (<a href="Quipper-Internal-QData.html#t:QData" title="Quipper.Internal.QData">QData</a> x, <a href="Quipper-Internal-QData.html#t:QData" title="Quipper.Internal.QData">QData</a> y) =&gt; (x -&gt; <a href="Quipper-Internal-Monad.html#t:Circ" title="Quipper.Internal.Monad">Circ</a> y) -&gt; x -&gt; (<a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:CircState" title="Quipper.Libraries.ClassicalOptim.Circuit">CircState</a>, &#91;<a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a>&#93;)</li><li class="src short"><a href="#v:myGateToQuipperGate">myGateToQuipperGate</a> :: <a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Gate" title="Quipper.Libraries.ClassicalOptim.Circuit">Gate</a> -&gt; <a href="Quipper-Internal-Circuit.html#t:Gate" title="Quipper.Internal.Circuit">Gate</a></li><li class="src short"><a href="#v:makeComment">makeComment</a> :: <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; &#91;<a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a>&#93; -&gt; <a href="Quipper-Internal-Circuit.html#t:Gate" title="Quipper.Internal.Circuit">Gate</a></li><li class="src short"><a href="#v:quipperBCircuitSimpl">quipperBCircuitSimpl</a> :: <a href="Quipper-Internal-Circuit.html#t:BCircuit" title="Quipper.Internal.Circuit">BCircuit</a> -&gt; &#91;<a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a>&#93; -&gt; (<a href="Quipper-Internal-Circuit.html#t:BCircuit" title="Quipper.Internal.Circuit">BCircuit</a>, &#91;<a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a>&#93;)</li><li class="src short"><a href="#v:simplify_classical-39-">simplify_classical'</a> :: (<a href="Quipper-Internal-QData.html#t:QData" title="Quipper.Internal.QData">QData</a> x, <a href="Quipper-Internal-QData.html#t:QData" title="Quipper.Internal.QData">QData</a> y) =&gt; (x -&gt; <a href="Quipper-Internal-Monad.html#t:Circ" title="Quipper.Internal.Monad">Circ</a> y) -&gt; x -&gt; (<a href="Quipper-Internal-Circuit.html#t:BCircuit" title="Quipper.Internal.Circuit">BCircuit</a>, &#91;<a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a>&#93;)</li><li class="src short"><a href="#v:simplify_classical">simplify_classical</a> :: (<a href="Quipper-Internal-QData.html#t:QData" title="Quipper.Internal.QData">QData</a> x, <a href="Quipper-Internal-QData.html#t:QData" title="Quipper.Internal.QData">QData</a> y) =&gt; (x -&gt; <a href="Quipper-Internal-Monad.html#t:Circ" title="Quipper.Internal.Monad">Circ</a> y) -&gt; x -&gt; <a href="Quipper-Internal-Monad.html#t:Circ" title="Quipper.Internal.Monad">Circ</a> y</li><li class="src short"><a href="#v:classical_to_reversible_optim">classical_to_reversible_optim</a> :: (<a href="Quipper-Internal-QData.html#t:QData" title="Quipper.Internal.QData">QData</a> qa, <a href="Quipper-Internal-QData.html#t:QData" title="Quipper.Internal.QData">QData</a> qb) =&gt; (qa -&gt; <a href="Quipper-Internal-Monad.html#t:Circ" title="Quipper.Internal.Monad">Circ</a> qb) -&gt; (qa, qb) -&gt; <a href="Quipper-Internal-Monad.html#t:Circ" title="Quipper.Internal.Monad">Circ</a> (qa, qb)</li><li class="src short"><a href="#v:box_classical_to_reversible_optim">box_classical_to_reversible_optim</a> :: (<a href="Quipper-Internal-QData.html#t:QData" title="Quipper.Internal.QData">QData</a> qa, <a href="Quipper-Internal-QData.html#t:QData" title="Quipper.Internal.QData">QData</a> qb) =&gt; <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; (qa -&gt; <a href="Quipper-Internal-Monad.html#t:Circ" title="Quipper.Internal.Monad">Circ</a> qb) -&gt; (qa, qb) -&gt; <a href="Quipper-Internal-Monad.html#t:Circ" title="Quipper.Internal.Monad">Circ</a> (qa, qb)</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Auxiliary functions</h1></a><div class="top"><p class="src"><a id="v:getListWire" class="def">getListWire</a> :: <a href="Quipper-Internal-QData.html#t:QData" title="Quipper.Internal.QData">QData</a> qc =&gt; qc -&gt; &#91;<a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a>&#93; <a href="src/Quipper/Libraries/ClassicalOptim/QuipperInterface.html#line-44" class="link">Source</a> <a href="#v:getListWire" class="selflink">#</a></p><div class="doc"><p>Extract the list of wires from a piece of quantum data.</p></div></div><a href="#g:2" id="g:2"><h1>Quipper circuits to simple circuits</h1></a><div class="top"><p class="src"><a id="v:quipperGateToMyGate" class="def">quipperGateToMyGate</a> :: (<a href="http://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-IntSet.html#t:IntSet" title="Data.IntSet">IntSet</a>, <a href="http://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-IntMap-Strict-Internal.html#t:IntMap" title="Data.IntMap.Strict.Internal">IntMap</a> <a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a>, <a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a>) -&gt; <a href="Quipper-Internal-Circuit.html#t:Gate" title="Quipper.Internal.Circuit">Gate</a> -&gt; ((<a href="http://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-IntSet.html#t:IntSet" title="Data.IntSet">IntSet</a>, <a href="http://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-IntMap-Strict-Internal.html#t:IntMap" title="Data.IntMap.Strict.Internal">IntMap</a> <a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a>, <a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a>), <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> <a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Gate" title="Quipper.Libraries.ClassicalOptim.Circuit">Gate</a>) <a href="src/Quipper/Libraries/ClassicalOptim/QuipperInterface.html#line-60" class="link">Source</a> <a href="#v:quipperGateToMyGate" class="selflink">#</a></p><div class="doc"><p>Translates a Quipper circuit to a simple circuit. The only gates
 considered are initializations, terminations, and multi-controlled
 NOT gates. All other gates are ignored.</p><p>Note that simple circuits do not possess termination wires: these
 wires are simply not terminated, and all subsequent initializations
 using the same wire ID are sent to fresh wires.</p><p>The state of this function is a bit complex, as it keeps track of
 where the output wires are mapped to.</p></div></div><div class="top"><p class="src"><a id="v:quipperGateInitW" class="def">quipperGateInitW</a> :: <a href="Quipper-Internal-Circuit.html#t:Gate" title="Quipper.Internal.Circuit">Gate</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> <a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a> <a href="src/Quipper/Libraries/ClassicalOptim/QuipperInterface.html#line-71" class="link">Source</a> <a href="#v:quipperGateInitW" class="selflink">#</a></p><div class="doc"><p>Get the wire initialized by the gate, if it is an initialization gate.</p></div></div><div class="top"><p class="src"><a id="v:quipperGateFreshWire" class="def">quipperGateFreshWire</a> :: <a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a> -&gt; &#91;<a href="Quipper-Internal-Circuit.html#t:Gate" title="Quipper.Internal.Circuit">Gate</a>&#93; -&gt; <a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a> <a href="src/Quipper/Libraries/ClassicalOptim/QuipperInterface.html#line-76" class="link">Source</a> <a href="#v:quipperGateFreshWire" class="selflink">#</a></p><div class="doc"><p>Given a list of Quipper gates, get the smallest wire id not in use.</p></div></div><div class="top"><p class="src"><a id="v:quipperCircuitToMyCirc" class="def">quipperCircuitToMyCirc</a> :: <a href="Quipper-Internal-Circuit.html#t:Circuit" title="Quipper.Internal.Circuit">Circuit</a> -&gt; <a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:CircState" title="Quipper.Libraries.ClassicalOptim.Circuit">CircState</a> <a href="src/Quipper/Libraries/ClassicalOptim/QuipperInterface.html#line-80" class="link">Source</a> <a href="#v:quipperCircuitToMyCirc" class="selflink">#</a></p><div class="doc"><p>Send a Quipper <code><a href="Quipper-Internal-Circuit.html#t:Circuit" title="Quipper.Internal.Circuit">Circuit</a></code> to a <code><a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:CircState" title="Quipper.Libraries.ClassicalOptim.Circuit">CircState</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:quipperBCircuitToMyCirc" class="def">quipperBCircuitToMyCirc</a> :: <a href="Quipper-Internal-Circuit.html#t:BCircuit" title="Quipper.Internal.Circuit">BCircuit</a> -&gt; <a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:CircState" title="Quipper.Libraries.ClassicalOptim.Circuit">CircState</a> <a href="src/Quipper/Libraries/ClassicalOptim/QuipperInterface.html#line-88" class="link">Source</a> <a href="#v:quipperBCircuitToMyCirc" class="selflink">#</a></p><div class="doc"><p>Send a Quipper <code><a href="Quipper-Internal-Circuit.html#t:BCircuit" title="Quipper.Internal.Circuit">BCircuit</a></code> to a <code><a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:CircState" title="Quipper.Libraries.ClassicalOptim.Circuit">CircState</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:myCircErrMsg" class="def">myCircErrMsg</a> :: <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="src/Quipper/Libraries/ClassicalOptim/QuipperInterface.html#line-92" class="link">Source</a> <a href="#v:myCircErrMsg" class="selflink">#</a></p><div class="doc"><p>Generate a custom error message.</p></div></div><div class="top"><p class="src"><a id="v:quipperFunToMyCirc" class="def">quipperFunToMyCirc</a> :: (<a href="Quipper-Internal-QData.html#t:QData" title="Quipper.Internal.QData">QData</a> x, <a href="Quipper-Internal-QData.html#t:QData" title="Quipper.Internal.QData">QData</a> y) =&gt; (x -&gt; <a href="Quipper-Internal-Monad.html#t:Circ" title="Quipper.Internal.Monad">Circ</a> y) -&gt; x -&gt; (<a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:CircState" title="Quipper.Libraries.ClassicalOptim.Circuit">CircState</a>, &#91;<a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a>&#93;) <a href="src/Quipper/Libraries/ClassicalOptim/QuipperInterface.html#line-98" class="link">Source</a> <a href="#v:quipperFunToMyCirc" class="selflink">#</a></p><div class="doc"><p>Given a Quipper circuit generating function and a shape argument,
 return a simple circuit together with the list of non-garbage
 circuit outputs.</p></div></div><a href="#g:3" id="g:3"><h1>Simple circuits to Quipper circuits</h1></a><div class="top"><p class="src"><a id="v:myGateToQuipperGate" class="def">myGateToQuipperGate</a> :: <a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Gate" title="Quipper.Libraries.ClassicalOptim.Circuit">Gate</a> -&gt; <a href="Quipper-Internal-Circuit.html#t:Gate" title="Quipper.Internal.Circuit">Gate</a> <a href="src/Quipper/Libraries/ClassicalOptim/QuipperInterface.html#line-108" class="link">Source</a> <a href="#v:myGateToQuipperGate" class="selflink">#</a></p><div class="doc"><p>Translate a gate from the simple circuit model into a Quipper gate.</p></div></div><div class="top"><p class="src"><a id="v:makeComment" class="def">makeComment</a> :: <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; &#91;<a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a>&#93; -&gt; <a href="Quipper-Internal-Circuit.html#t:Gate" title="Quipper.Internal.Circuit">Gate</a> <a href="src/Quipper/Libraries/ClassicalOptim/QuipperInterface.html#line-116" class="link">Source</a> <a href="#v:makeComment" class="selflink">#</a></p><div class="doc"><p>Generate a Quipper comment. The first argument is a comment
 string, and the second argument is a label to apply to the qubits
 in the third argument.</p></div></div><a href="#g:4" id="g:4"><h1>Algebraic optimization of Quipper circuits</h1></a><div class="top"><p class="src"><a id="v:quipperBCircuitSimpl" class="def">quipperBCircuitSimpl</a> :: <a href="Quipper-Internal-Circuit.html#t:BCircuit" title="Quipper.Internal.Circuit">BCircuit</a> -&gt; &#91;<a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a>&#93; -&gt; (<a href="Quipper-Internal-Circuit.html#t:BCircuit" title="Quipper.Internal.Circuit">BCircuit</a>, &#91;<a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a>&#93;) <a href="src/Quipper/Libraries/ClassicalOptim/QuipperInterface.html#line-127" class="link">Source</a> <a href="#v:quipperBCircuitSimpl" class="selflink">#</a></p><div class="doc"><p>Optimize a Quipper <code><a href="Quipper-Internal-Circuit.html#t:BCircuit" title="Quipper.Internal.Circuit">BCircuit</a></code>. The second argument is the list
 of non-garbage outputs. A corresponding list of outputs is also
 returned along with the circuit.</p></div></div><div class="top"><p class="src"><a id="v:simplify_classical-39-" class="def">simplify_classical'</a> :: (<a href="Quipper-Internal-QData.html#t:QData" title="Quipper.Internal.QData">QData</a> x, <a href="Quipper-Internal-QData.html#t:QData" title="Quipper.Internal.QData">QData</a> y) =&gt; (x -&gt; <a href="Quipper-Internal-Monad.html#t:Circ" title="Quipper.Internal.Monad">Circ</a> y) -&gt; x -&gt; (<a href="Quipper-Internal-Circuit.html#t:BCircuit" title="Quipper.Internal.Circuit">BCircuit</a>, &#91;<a href="Quipper-Libraries-ClassicalOptim-Circuit.html#t:Wire" title="Quipper.Libraries.ClassicalOptim.Circuit">Wire</a>&#93;) <a href="src/Quipper/Libraries/ClassicalOptim/QuipperInterface.html#line-145" class="link">Source</a> <a href="#v:simplify_classical-39-" class="selflink">#</a></p><div class="doc"><p>Optimize a Quipper circuit producing function (together with a
 shape argument). Return the optimized circuit as a Quipper
 <code><a href="Quipper-Internal-Circuit.html#t:BCircuit" title="Quipper.Internal.Circuit">BCircuit</a></code>, along with a list of the non-garbage circuit outputs.</p></div></div><div class="top"><p class="src"><a id="v:simplify_classical" class="def">simplify_classical</a> :: (<a href="Quipper-Internal-QData.html#t:QData" title="Quipper.Internal.QData">QData</a> x, <a href="Quipper-Internal-QData.html#t:QData" title="Quipper.Internal.QData">QData</a> y) =&gt; (x -&gt; <a href="Quipper-Internal-Monad.html#t:Circ" title="Quipper.Internal.Monad">Circ</a> y) -&gt; x -&gt; <a href="Quipper-Internal-Monad.html#t:Circ" title="Quipper.Internal.Monad">Circ</a> y <a href="src/Quipper/Libraries/ClassicalOptim/QuipperInterface.html#line-156" class="link">Source</a> <a href="#v:simplify_classical" class="selflink">#</a></p><div class="doc"><p>Optimize a Quipper circuit-producing function. This assumes that
 the function only consists of pseudo-classical quantum gates, i.e.,
 initializations, terminations, and (possibly multiply controlled)
 NOT gates. The behavior on other kinds of circuits is undefined.
 The second argument is a shape parameter.</p></div></div><div class="top"><p class="src"><a id="v:classical_to_reversible_optim" class="def">classical_to_reversible_optim</a> :: (<a href="Quipper-Internal-QData.html#t:QData" title="Quipper.Internal.QData">QData</a> qa, <a href="Quipper-Internal-QData.html#t:QData" title="Quipper.Internal.QData">QData</a> qb) =&gt; (qa -&gt; <a href="Quipper-Internal-Monad.html#t:Circ" title="Quipper.Internal.Monad">Circ</a> qb) -&gt; (qa, qb) -&gt; <a href="Quipper-Internal-Monad.html#t:Circ" title="Quipper.Internal.Monad">Circ</a> (qa, qb) <a href="src/Quipper/Libraries/ClassicalOptim/QuipperInterface.html#line-164" class="link">Source</a> <a href="#v:classical_to_reversible_optim" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Quipper-Internal-Classical.html#v:classical_to_reversible" title="Quipper.Internal.Classical">classical_to_reversible</a></code>, but also apply circuit optimization.</p></div></div><div class="top"><p class="src"><a id="v:box_classical_to_reversible_optim" class="def">box_classical_to_reversible_optim</a> :: (<a href="Quipper-Internal-QData.html#t:QData" title="Quipper.Internal.QData">QData</a> qa, <a href="Quipper-Internal-QData.html#t:QData" title="Quipper.Internal.QData">QData</a> qb) =&gt; <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; (qa -&gt; <a href="Quipper-Internal-Monad.html#t:Circ" title="Quipper.Internal.Monad">Circ</a> qb) -&gt; (qa, qb) -&gt; <a href="Quipper-Internal-Monad.html#t:Circ" title="Quipper.Internal.Monad">Circ</a> (qa, qb) <a href="src/Quipper/Libraries/ClassicalOptim/QuipperInterface.html#line-169" class="link">Source</a> <a href="#v:box_classical_to_reversible_optim" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Quipper-Libraries-ClassicalOptim-QuipperInterface.html#v:classical_to_reversible_optim" title="Quipper.Libraries.ClassicalOptim.QuipperInterface">classical_to_reversible_optim</a></code>, but insert the optimized
 circuit as a boxed subroutine.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>
